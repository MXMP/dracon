*Dracon* (**Dra**ft of the **con**fig) - TFTP-сервер для FreeBSD, предназначенный для генерации конфигурационных файлов по требованию. Файлы генерируются на основе простых текстовых шаблонов, выгружаются по TFTP-протоколу и размещаются в базе MongoDB. Отправляемые на сервер файлы также размещаются в базе данных.

## Предназначение сервиса

Сервис **Dracon** изначально разрабатывался для генерации 'на лету' конфигурационных файлов для коммутаторов D-Link, таких как *DES-3028*, *DES-3200* и т.д. При конфигурировании этих устройств очень часто нужно определять команды с учетом роли портов. Так, например, при настройке функционала обнаружения петель, сегментации трафика и управления мультикаст-трафиком требуется заранее определить как будет использоваться тот или иной порт. Очевидно, что обнаружение петель имеет смысл включать только на тех портах, куда будет подключено клиентское оборудование, а при конфигурировании *multicast-vlan* в качестве источника трафика требуется явно задать *uplink*-порт.

Роли портов можно определять заранее. Например, для всех коммутаторов *DES-3200-28* можно использовать порты *1-24* как **абонентские**, *25-28* как **магистральные**, а сам *25*-й порт при этом считать **аплинком**. Однако, чем больше разрастается сеть, тем больше появляется вынужденных отклонений от схемы - иногда приходится использовать другой порт в качестве аплинка, подключать собственное оборудование в абонентские порты или же абонентов в магистральные. При этом конфигурация, которая была разработана для "стандартного" коммутатора, приведет к неправильной работе устройства. Загружая на устройство такую конфигурацию нужно быть готовым к непредвиденным последствиям. © :)

Для решения этой проблемы необходимо хранить в биллинге тип (роль) каждого порта и строить конфигурацию с учетом этих типов. Делать такое вручную, разумеется, неудобно. Именно поэтому появился сервис **Dracon**, который создает **конфигурацию автоматически, опираясь на данные биллинга.**

## Возможности Dracon

* Генерация конфигурационного файла с учетом типов портов и нескольких пользовательских параметров
* Сохранение файлов, передаваемых в обоих направлениях, в базе MongoDB (кроме файлов ПО)
* Возможность выгрузки программного обеспечения (прошивки) вместо файла конфигурации
* Применение пользовательских функций для обработки пользовательских параметров
* Возможность выгрузки по запросу конкретной секции конфигурационного файла
* Работа одновременно с несколькими устройствами (TFTP-клиентами)

## Особенности работы

* Работа системным сервисом (daemon) под FreeBSD
* Гибкая система конфигурирования, возможность определять типы портов, устройств и доступных команд
* Отсутствие привязки к конкретному оборудованию или вендору

## Требования

* FreeBSD (для работы системным демоном)
* Python + MySQLdb + PyMongo
* Доступ к вашему MySQL-серверу (базе биллинга) для получения списка устройств и портов
* Доступ к MongoDB для сохранения файлов (опционально)

## Принцип работы

**Dracon** запускается системным сервисом и периодически забирает из биллинга информацию о коммутаторах и их портах. Первым выполняется запрос для получения информации о портах. Он должен вернуть таблицу вида:

ip         | port | ptype | comment1 | comment2
-----------|------|-------|----------|---------
10.90.90.95|   1  |   1   |user12345 |   VIP

В этом запросе **ptype** определяет тип (роль) порта - **абонентский**, **магистральный**, **неисправный** и т.д. Параметры *comment1* и *comment2* - произвольные комментарии. В моем случае я использую *comment1* для хранения логина пользователя из биллинга, а *comment2* для описания порта из биллинга.

Затем запрашивается информация об устройствах. Запрос должен вернуть таблицу вида:

ip         | type |      custom1     |      custom2
-----------|------|-----------------|-----------------
10.90.90.95|  24  | 192.168.0.0/24  | Отдел разработки

Здесь **type** - это идентификатор типа устройства. В дальнейшем для удобства происходит сопоставлению типов текстовым именам устройств. Параметр *custom1* и *custom2* - произвольные данные. В моем случае я использую *custom1* для хранения сети, обслуживаемой коммутатором, а *custom1* для адресам установки коммутатора.

После этого **Dracon** начинает прослушивать порт 69 (по умолчанию) для работы в качестве TFTP-сервера. При получении запроса от устройства (или обычного TFTP-клиента) сервис либо сгенерирует и отдаст клиенту конфигурационный файл, если это был запрос на чтение, либо примет от клиента файл, если это был запрос на запись. Выгруженные и загруженные файлы помещаются в базу данных MongoDB.

Через 5 минут (по умолчанию) сервис перезапросит из биллинга информацию о коммутаторах и портах и актуализирует эти данные в своей памяти.

## Конфигурирование
### Описание параметров в файле dconfig.py

#### Общие настройки программы
 Параметр | Описание
----------|---------
interface | Интерфейс, на котором будет работать демон.
port      | UDP-порт для tftp-сервера.
cycle_int | Количество секунд, через которое надо обновлять список портов и устройств.
sleep_def | Пауза по умолчанию при опросе UDP-сокета.
sleep_int | Количество секунд простоя (данные не поступают), через которые надо выставить паузу по умолчанию.
logfile   | Лог-файл демона.

Здесь необходимо сделать пояснение относительно пауз. **Dracon** опрашивает сокет в бесконечном цикле, ожидая поступления данных. В подавляющем большинстве случаев данные не поступают, и чтобы не выполнять бесполезную работу слишком часто, этот опрос выполняется с задержкой *sleep_def*. После того, как был получен запрос от клиента, это значение делится на *1000*, чтобы успеть передать файл за меньшее время. Когда передача данных завершилась и прошел интервал *sleep_int*, сервис переходит в обычный режим и снова начинает использовать значение *sleep_def*.


#### Настройки для MySQL-сервера, откуда будут забираться данные
   Параметр   | Описание
--------------|---------
mysql_addr    | Адрес MySQL-сервера биллинга.
mysql_user    | Имя пользователя.
mysql_pass    | Пароль.
mysql_base    | Имя базы данных.
mysql_query_p | MySQL-запрос для получения IP-адресов и данных о портах коммутатора.
mysql_query_d | MySQL-запрос для получения данных о коммутаторах: IP-адрес, тип, сеть, адрес.
inc_cpage     | Кодировка данных в результате запроса (используется для транслитерации кириллицы).

Параметр *inc_cpage* используется для функции транслитерации кириллицы.

#### Настройки для сервера MongoDB, где будут храниться результаты работы
  Параметр | Описание
-----------|---------
use_mongo  | Сохранять файлы в базе MongoDB (True/False).
mongo_addr | Адрес MongoDB-сервера.
mongo_user | Имя пользователя.
mongo_pass | Пароль.
mongo_base | Имя базы данных.
mongo_ucol | Имя коллекции для загружаемых файлов.
mongo_dcol | Имя коллекции для выгружаемых файлов.


#### Распознавание устройств и их типов
 Параметр | Описание
----------|---------
dev_types | Соответствие идентификаторов типов устройств и их названий.

Параметр *dev_types* задается в виде словаря *python*. Пример:
```python
dev_types = {
     25:'DES-3200-28',
    131:'DES-3028',
     86:'DES-3200-18',
    112:'DES-3200-28_C1'
}
```

   Параметр   | Описание
--------------|---------
default_ports | Пустой набор портов по умолчанию: 1-24 - абонентские порты, 25 - uplink, 26-28 - downlink'и

Параметр *dev_types* задается в виде словаря *python* и содержит типы и набор портов по умолчанию. Он пригодится в случае, если устройство не определено по каким-либо причинам. В этом случае будет выгружена конфигурация по умолчанию. Во всяком случае, задумка была такая. :) Пример:
```python
default_ports = {'0.0.0.0':
        {1: {'type':'1', 'desc':'', 'user':'subscriber'},  2: {'type':'1', 'desc':'', 'user':'subscriber'},  3: {'type':'1', 'desc':'', 'user':'subscriber'},  4: {'type':'1', 'desc':'', 'user':'subscriber'},
.......
.......
.......
        25: {'type':'5', 'desc':  'uplink', 'user':''  }, 26: {'type':'2', 'desc':'downlink','user':''   }, 27: {'type':'2', 'desc':'downlink','user':''   }, 28: {'type':'2', 'desc':'downlink','user':''   }
        }
}
```
 
  Параметр  | Описание
------------|---------
ports_types | Словарь с кодами портов и их сокращенными обозначениями

Параметр *ports_types* содержит соответствие буквенного кода порта цифровому коду. Для себя я определил 9 типов портов:

Код | Тип
----|---
  1 | абонентский порт
  2 | магистральный
  3 | сломанный
  4 | VIP-клиент
  5 | вход
  6 | нестандартный
  7 | оборудование
  8 | вход (патчкорд)
  9 | магистраль (патчкорд)

Такие обозначения сложились исторически и, в принципе, удовлетворяют почти всем потребностям по разграничению ролей портов.

Параметр *ports_types* задается в виде словаря *python*. Пример:
```python
ports_types = {1:'ss',2:'mg',3:'br',4:'vp',5:'up',6:'ns',7:'eq',8:'pu',9:'pd'}
```
  
 Параметр | Описание
----------|---------
mags_list | Список кодов магистральных портов.

Параметр *mags_list* определяет произвольный набор портов как **магистральные** и задается в виде списка *python*. пример:
```python
mags_list   = [2,5,8,9]
```

 Параметр | Описание
----------|---------
 cf_path  | Путь к каталогу с файлами конфигураций.


Имя файла конфигураций должно соответствовать названию устройства (см. **dev_types**). Например,  для устройства с ID=112 по пути */usr/local/etc/dracon/config/* (значение **cf_path**) будет производиться поиск файла **DES-3200-28_C1**.

 Параметр | Описание
----------|---------
fw_names  | Соответствие названий устройств и файлов с программным обеспечением

Короче говоря, *fw_names* содержит имя файла "прошивки" для конкретного коммутатора. Этот параметр задается в виде словаря *python*. Пример:

```python
fw_names = {
    'DES-3200-28'   : 'DES-3200R_1.85.B008.had',
    'DES-3028'      : 'DES_3028_52_V2.94-B07.had',
    'DES-3200-18'   : 'DES-3200R_1.85.B008.had',
    'DES-3200-28_C1': 'DES3200R_4.39.B008.had'
    }
```

#### Команды сервиса
 Параметр | Описание
----------|---------
 commands | Доступные команды (имена файлов) и соответствующие им шаблоны с набором команд
Параметр *ports_types* задается в виде **словаря списков** *python*. Пример:

```python
commands = {
    'acl':['*header*', '*acl*'],
    'cpu_acl':['*header*', '*cpu_acl*'],
    'accounts':['*header*', '*accounts*'],
    'stp_lbd':['*header*', '*stp_lbd*'],
    'snmp':['*header*', '*snmp*'],
    'sntp':['*header*', '*sntp*'],
    'lldp':['*header*', '*lldp*'],
    'filtering':['*header*', '*filtering*'],
    'trusted_hosts':['*header*', '*trusted_hosts*'],
    'ipm':['*header*', '*ipm*'],
    'dhcp_relay':['*header*', '*dhcp_relay*'],
    'igmp_snooping':['*header*', '*igmp_snooping*'],
    'igmp_auth':['*header*', '*igmp_auth*'],
    'aaa':['*header*', '*aaa*'],
    'multi_filter':['*header*', '*multi_filter*'],
    'cos':['*header*', '*cos*'],
    'mon_log':['*header*', '*mon_log*'],
    'pdesc':['*header*', '*p_desc*'],
    'config':['*header*', '*acl*', '*cpu_acl*', '*accounts*', '*stp_lbd*', '*snmp*', '*sntp*', '*lldp*', '*filtering*', '*trusted_hosts*',
    '*ipm*', '*dhcp_relay*', '*igmp_snooping*', '*igmp_auth*', '*aaa*', '*multi_filter*', '*cos*', '*mon_log*', '*p_desc*', '*bottom*']
    }
```

Что значит сия конструкция? А все просто: если запросить у сервиса **Dracon** файл с именем **acl**, то программа заглянет в *commands*, увидит, что этому имени соответствуют секции конфигурационного файла с именами **\*header\*** и **\*acl\***, найдет эту секции в шаблоне файла, обработает и выдаст их содержимое. Подробнее о секциях будет рассказано ниже.

Нетрудно догадаться, что файл с именем **config** содержит все доступные команды.

Параметр | Описание
---------|---------
helpinfo | Содержимое справки, получаемой по команде (имени файла) 'help'

Параметр *helpinfo* представляет собой строку, в которой можно написать мини-справку, возвращаемую при выполнении команды **help**


**Примечание**: С точки зрения TFTP-клиента **команда** является **именем файла**.
Чтобы выполнить команду *config*, нужно затребовать с TFTP-сервера файл **config**.

Можно выполнять команды применительно к конкретному устройству, например, команда:
```
tftp -i dracon.myhost get 10.90.90.100@config
```

выгрузит полную конфигурацию для устройства с IP-адресом *10.90.90.100*.


### Описание параметров в файле dfunc.py

**Dracon** позволяет использовать пользовательские функции для обработки параметров *comment* и *custom*. Эти функции хранятся в файле **dfunc.py** и написаны на обычном *python*. Примеры функций:

#### Пользовательская функция: Получение hex-значения 2-го октета IP-адреса
```python
def fn_2oct(src):
    try:
        return hex(int(src.split('.')[1]))[2:].zfill(2)
    except:
        return ""
```
#### Пользовательская функция: Получение hex-значения 3-го октета IP-адреса
```python
def fn_3oct(src):
    try:
        return hex(int(src.split('.')[2]))[2:].zfill(2)
    except:
        return ""
```
#### Пользовательская функция: Получение hex-значения номера порта
```python
def fn_xp(n):
    try:
        return hex(int(n))[2:].zfill(2)
    except:
        return ""
```
#### Пользовательская функция: Получение значений полей custom#
```python
def fn_cst(src):
    return src
```

О практическом применении пользовательских функций рассказано в следующем разделе.


## Написание шаблонов конфигурации

Ну вот мы и подошли к самому интересному - к написанию шаблонов конфигурационных файлов. Предположим, мы хотим создать шаблон файла конфигурации для устройства **DES-3200-28/C1**. Согласно параметрам **cf_path** и **dev_types** файл шаблона должен находиться по адресу **/usr/local/etc/dracon/config/DES-3200-28_C1**.

Структура файла шаблона:
```
***Заголовок секции***
Тело
...
секции
<пустая строка>

***Заголовок другой секции***
Тело другой секции
<пустая строка>

```

Пример секции, содержащей "шапку" конфигурационного файла коммутатора:
```
:::*header*:::
#-------------------------------------------------------------------------------
#                       DES-3200-28 Fast Ethernet Switch
#                                Configuration
#
#                          Firmware: Build 4.39.B008
#           Copyright(C) 2012 D-Link Corporation. All rights reserved.
#
```

Внутри тела секции мы можем использовать специальные конструкции, которые при выгрузке будут заменены на некоторые значения.
Специальная конструкция **[mags]** будет заменена на диапазон портов коммутаторы с типами, которые были описаны в переменной **mags_list**. А конструкция **[all]** будет заменена на диапазон всех портов коммутатора. Для стандартных настроек это, скорее всего, будут значения **25-28** и **1-28** соответственно.

В параметре **ports_types** мы определяли буквенные обозначения диапазонов портов. Так, конструкция **[ss]** будет заменена на диапазон всех портов с кодом 1, а конструкция **[eq]** - на диапазон всех портов с кодом 7. В первом случае для стандартного коммутатора это будет значение **1-24**.

Можно получить конкретный порт из диапазона. Конструкция **[ss#5]** будет заменена на **5** в случае, если порт №5 входит в диапазон портов **[ss]**.

Пользовательская функция вызывается конструкцией вида **(fn_2oct#custom1)**. В данном примере будет вызвана пользовательская функция **fn_2oct**, а в качестве параметра ей будет передано значение **custom1**. В нашем примере в результате замены будет возвращено значение **A8** (custom1=192.**168**.0.0/24).

Можно получить комментарий для конкретного порта используя конструкцию вида **(comment1#1)**. В этом случае при замене будет произведена замена шаблона на значение **comment1** порта **1**.

**Внимание!**
Если условие для замены не выполнилось, строка будет закомментирована символом **#**, а заменяемая конструкция останется неизменной.

Пример: У нас есть порт **25** с кодом **5** (**up**) и нет портов с кодом **8** (**pu**). В этом случае строки
```
config igmp_snooping multicast_vlan mvr add source_port [up]
config igmp_snooping multicast_vlan mvr add source_port [pu]
```
будут возвращены как
```
config igmp_snooping multicast_vlan mvr add source_port 25
#config igmp_snooping multicast_vlan mvr add source_port [pu]
```
Вторая команда не будет выполнена коммутатором, т.к. начинается с символа **#**.


### Примеры использования заменяемых конструкций

#### Подстановка диапазона абонентских и магистральных портов
```
config cpu_filter l3_control_pkt   [ss] all state enable
config cpu_filter l3_control_pkt [mags] all state disable
```
#### Подстановка значения comment1 и comment2 для портов 1 и 2
```
config ports  1 description "(comment1#1) ((comment2#1))"
config ports  2 description "(comment1#2) ((comment2#2))"
```
#### Вызов пользовательской функции fn_cst с параметром custom2
```
config snmp system_location (fn_cst#custom2)
```
#### Вызов пользовательских функций fn_2oct и fn_3oct с параметром custom1 и подстановка номеров портов 1 и 2 из диапазона абонентских портов.
```
config access_profile profile_name pcf add access_id 101 packet_content offset_chunk_1 0x0800 offset_chunk_2 0x0A(fn_2oct#custom1)(fn_3oct#custom1)08 port  [ss#1] permit
config access_profile profile_name pcf add access_id 102 packet_content offset_chunk_1 0x0800 offset_chunk_2 0x0A(fn_2oct#custom1)(fn_3oct#custom1)10 port  [ss#2] permit
```

## Установка

 * Скопируйте файл **dracon** в */usr/local/etc/rc.d/*, а остальные файлы в */usr/local/etc/dracon/*.
 * Добавьте строку **dracon_enable="YES"** в файл */etc/rc.conf*.
 * Запустите сервис командой **service dracon start**.

